# Алгоритмічна складність, наближені та рандомізовані алгоритми

## Завдання 1. Порівняння рандомізованого та детермінованого QuickSort

Реалізуйте рандомізований та детермінований алгоритми сортування QuickSort.
Проведіть порівняльний аналіз їхньої ефективності, вимірявши середній час виконання на масивах різного розміру.

**Технічні умови**

1. Для реалізації рандомізованого алгоритму QuickSort реалізуйте функцію `randomized_quick_sort(arr)`, де опорний елемент (pivot) обирається випадковим чином.

2. Для реалізації детермінованого алгоритму QuickSort реалізуйте функцію `deterministic_quick_sort(arr)`, де опорний елемент обирається за фіксованим правилом: перший, останній або середній елемент.

3. Створіть набір тестових масивів різного розміру: `10_000`, `50_000`, `100_000` та `500_000` елементів. Заповніть масиви випадковими цілими числами.

4. Виміряйте час виконання обох алгоритмів на кожному масиві. Для більш точної оцінки повторіть сортування кожного масиву 5 разів та обчисліть середній час виконання.

**Результати виконання**

```
Розмір масиву: 10000
   Рандомізований QuickSort: 0.0164 секунд
   Детермінований QuickSort: 0.0145 секунд
Розмір масиву: 50000
   Рандомізований QuickSort: 0.0943 секунд
   Детермінований QuickSort: 0.0893 секунд
Розмір масиву: 100000
   Рандомізований QuickSort: 0.2020 секунд
   Детермінований QuickSort: 0.1881 секунд
Розмір масиву: 500000
   Рандомізований QuickSort: 1.2769 секунд
   Детермінований QuickSort: 1.2156 секунд
```

![](/img/diagram.jpg)

**Висновки**

1. Детермінований QuickSort працює швидше

- У всіх тестах детермінований QuickSort показав кращі результати, ніж рандомізований.
- Різниця в швидкості є невеликою, але помітною, особливо на великих масивах.

2. Різниця в продуктивності стає більш відчутною зі збільшенням розміру масиву

- Наприклад, для масиву з 10000 елементів різниця в часі між алгоритмами ~0.0019 секунд.
- Для 500000 елементів ця різниця зросла до ~0.0613 секунд.

3. Можливі причини кращої продуктивності детермінованого QuickSort

- Використання середнього елемента як опорного (pivot) у детермінованому алгоритмі могло призвести до кращого розбиття масиву, зменшуючи кількість рекурсивних викликів.
- У рандомізованому QuickSort випадковий вибір опорного елемента може іноді призводити до менш ефективного поділу, що збільшує кількість рекурсій.

4. Обидва алгоритми мають однакову часову складність O(n log n) в середньому випадку

- Обидва алгоритми є ефективними для сортування великих масивів.
- Детермінований QuickSort може бути стабільнішим, якщо вибір pivot робиться за хорошою стратегією (наприклад, середній елемент).
- Рандомізований QuickSort корисний у випадках, коли потрібно уникати найгіршого випадку O(n²) (наприклад, при вже відсортованих або частково відсортованих масивах).

## Завдання 2. Складання розкладу занять за допомогою жадібного алгоритму

Реалізуйте програму для складання розкладу занять в університеті, використовуючи жадібний алгоритм для задачі покриття множини.
Мета полягає в призначенні викладачів на предмети таким чином, щоб мінімізувати кількість викладачів та покрити всі предмети.

**Технічні умови**

Дано множину предметів: {'Математика', 'Фізика', 'Хімія', 'Інформатика', 'Біологія'}

Список викладачів:

1. Олександр Іваненко, 45 років, `o.ivanenko@example.com`, предмети: `{'Математика', 'Фізика'}`

2. Марія Петренко, 38 років, `m.petrenko@example.com`, предмети: `{'Хімія'}`

3. Сергій Коваленко, 50 років, `s.kovalenko@example.com`, предмети: `{'Інформатика', 'Математика'}`

4. Наталія Шевченко, 29 років, `n.shevchenko@example.com`, предмети: `{'Біологія', 'Хімія'}`

5. Дмитро Бондаренко, 35 років, `d.bondarenko@example.com`, предмети: `{'Фізика', 'Інформатика'}`

6. Олена Гриценко, 42 роки, `o.grytsenko@example.com`, предмети: `{'Біологія'}`

**Опис завдання**

- Реалізуйте клас `Teacher` з такими атрибутами:
- `first_name` (ім'я)
- `last_name` (прізвище)
- `age` (вік)
- `email` (електронна пошта)
- `can_teach_subjects` (множина предметів, які може викладати)
- Реалізуйте функцію `create_schedule(subjects, teachers)`, яка використовує жадібний алгоритм для призначення викладачів на предмети.
  Функція повинна повернути список викладачів та предмети, які їм призначено.
- Під час вибору викладача на кожному етапі віддавайте перевагу тому, хто може викладати найбільшу кількість предметів, які ще не охоплені.
  Якщо таких кандидатів кілька, обирайте наймолодшого за віком.
